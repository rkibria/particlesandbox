<!DOCTYPE html>
<html>

<head>
<meta charset="utf-8">
<title>Particle Sandbox</title>
<style>
body {background-color: black;}

html *
{
	font-size: 1em;
	color: lightgray;
	font-family: Arial;
}

.button {
	background-color: #303030;
	width: 150px;
	border: solid 2px lightgray;
	color: lightgray;
	padding: 5px 3px;
	text-align: center;
	text-decoration: none;
	display: inline-block;
	margin: 4px 2px;
	cursor: pointer;
}

.button1 {font-size: 16px;}

input {
	width: 30%;
	background-color: #303030;
	color: white;
	padding: 1px 2px;
	margin: 2px 0;
	border: none;
	border-radius: 1px;
	cursor: pointer;
}

.float-left-child {
	float: left;
}

/* base css */
body {
	padding: 0px;
}
.parent {
	padding: 0px
}
.child {
	padding: 5px
}
</style>
</head>

<body>

<div class='parent'>
	<div class='child float-left-child'>
		<canvas id="canvas" width="800" height="800" style="border:0px;">Your browser does not support the HTML5 canvas tag.</canvas>
	</div>
	<div class='child float-left-child'>

		<div class='parent'>
			<div class='child float-left-child'>
				<button class="button button1" onclick="onResetButton()">Reset</button><br>
			</div>
			<div class='child float-left-child'>
				<button class="button button1" onclick="onRandomizeButton()">Randomize</button><br>
			</div>
		</div>

		<p style="margin-bottom:1px;">
		<form>
			<fieldset>
			<legend>Particles</legend>
				Amount <input type="number" id="ID_PARTICLES" min="1" value="50" onclick="onResetButton()" onkeydown="onResetButton()"><br>
				Radius <input type="number" id="ID_RADIUS" min="-50" max="50" value="3" onclick="onResetButton()" onkeydown="onResetButton()">(<0 for squares)<br>
				<input type="checkbox" id="ID_RADIUS_RANDOM" onclick="onResetButton()">Randomize radius<br>
				Mass <input type="number" id="ID_MASS" min="0.001" value="10" onclick="onResetButton()" onkeydown="onResetButton()"><br>
				Repulsion <input type="number" id="ID_REPULSION" min="-100" max="100" value="0.1" step="0.01" onclick="onResetButton()" onkeydown="onResetButton()"><br>
				Attraction <input type="number" id="ID_ATTRACTION" min="-100" max="100" value="0.5" step="0.01" onclick="onResetButton()" onkeydown="onResetButton()"><br>
				Friction <input type="number" id="ID_FRICTION" min="0" max="1" value="0.999" step="0.001" onclick="onResetButton()" onkeydown="onResetButton()"><br>
				Clamp speed <input type="number" id="ID_CLAMP_SPEED" min="0" max="50" value="7" step="0.1" onclick="onResetButton()" onkeydown="onResetButton()"><br>
				Spawns <input type="number" id="ID_SPAWN" min="0" value="10" onclick="onResetButton()" onkeydown="onResetButton()">(on collision)<br>
				Spawn probability <input type="number" id="ID_SPAWN_PROB" min="0" max="1" value="0" step="0.01" onclick="onResetButton()" onkeydown="onResetButton()"><br>
			</fieldset>
		</form>

		<p style="margin-bottom:1px;">
		<form>
			<fieldset>
			<legend>Settings</legend>
				Background RGB <br>
				<input type="number" id="ID_BG_R" min="0" max="255" value="0" step="1" onclick="onResetButton()" onkeydown="onResetButton()"><br>
				<input type="number" id="ID_BG_G" min="0" max="255" value="0" step="1" onclick="onResetButton()" onkeydown="onResetButton()"><br>
				<input type="number" id="ID_BG_B" min="0" max="255" value="0" step="1" onclick="onResetButton()" onkeydown="onResetButton()"><br>
			</fieldset>
		</form>

		<p style="margin-bottom:1px;">
		<form>
			<fieldset>
			<legend>Postprocessing</legend>
				Fading <input type="number" id="ID_FADE" min="0" max="1" value="0.5" step="0.05" onclick="onResetButton()" onkeydown="onResetButton()"><br>
				<input type="checkbox" id="ID_BLUR" onclick="onResetButton()">Blur (reload page to disable!)<br>
				Rotate deg <input type="number" id="ID_ROTATE" min="-360" max="360" value="0" step="1" onclick="onResetButton()" onkeydown="onResetButton()"><br>
				Translate x <input type="number" id="ID_TRANSLATE_X" min="-800" max="800" value="0" step="1" onclick="onResetButton()" onkeydown="onResetButton()"><br>
				Translate y <input type="number" id="ID_TRANSLATE_Y" min="-800" max="800" value="0" step="1" onclick="onResetButton()" onkeydown="onResetButton()"><br>
			</fieldset>
		</form>

		<p style="margin-bottom:1px;">
		<button class="button button1" onclick="onSaveButton()">Save png</button><br>

	</div>
</div>

<script>

var CSS_COLOR_NAMES = ["AliceBlue","AntiqueWhite","Aqua","Aquamarine","Azure","Beige","Bisque"
,"BlanchedAlmond","Blue","BlueViolet","Brown","BurlyWood","CadetBlue","Chartreuse","Chocolate"
,"Coral","CornflowerBlue","Cornsilk","Crimson","Cyan","DarkBlue","DarkCyan","DarkGoldenRod",
"DarkGray","DarkGrey","DarkGreen","DarkKhaki","DarkMagenta","DarkOliveGreen","Darkorange",
"DarkOrchid","DarkRed","DarkSalmon","DarkSeaGreen","DarkSlateBlue","DarkSlateGray",
"DarkSlateGrey","DarkTurquoise","DarkViolet","DeepPink","DeepSkyBlue","DimGray","DimGrey",
"DodgerBlue","FireBrick","FloralWhite","ForestGreen","Fuchsia","Gainsboro","GhostWhite","Gold"
,"GoldenRod","Gray","Grey","Green","GreenYellow","HoneyDew","HotPink","IndianRed","Indigo",
"Ivory","Khaki","Lavender","LavenderBlush","LawnGreen","LemonChiffon","LightBlue","LightCoral"
,"LightCyan","LightGoldenRodYellow","LightGray","LightGrey","LightGreen","LightPink",
"LightSalmon","LightSeaGreen","LightSkyBlue","LightSlateGray","LightSlateGrey",
"LightSteelBlue","LightYellow","Lime","LimeGreen","Linen","Magenta","Maroon",
"MediumAquaMarine","MediumBlue","MediumOrchid","MediumPurple","MediumSeaGreen",
"MediumSlateBlue","MediumSpringGreen","MediumTurquoise","MediumVioletRed","MidnightBlue",
"MintCream","MistyRose","Moccasin","NavajoWhite","Navy","OldLace","Olive","OliveDrab","Orange"
,"OrangeRed","Orchid","PaleGoldenRod","PaleGreen","PaleTurquoise","PaleVioletRed","PapayaWhip"
,"PeachPuff","Peru","Pink","Plum","PowderBlue","Purple","Red","RosyBrown","RoyalBlue",
"SaddleBrown","Salmon","SandyBrown","SeaGreen","SeaShell","Sienna","Silver","SkyBlue",
"SlateBlue","SlateGray","SlateGrey","Snow","SpringGreen","SteelBlue","Tan","Teal","Thistle",
"Tomato","Turquoise","Violet","Wheat","White","WhiteSmoke","Yellow","YellowGreen"];

///////////////////////////////////////////////////////////////////////////////
const canvas = document.getElementById('canvas');
const canvasW = canvas.scrollWidth, canvasH = canvas.scrollHeight;

///////////////////////////////////////////////////////////////////////////////
function gaussianRand()
{
	let rand = 0;
	for(let i = 0; i < 6; i += 1) {
		rand += Math.random();
	}
	return rand / 6;
}

function getRandomInt(min, max) {
	return Math.floor(Math.random() * (max - min + 1)) + min;
}

function getRandom(min, max) {
	return min + Math.random() * (max - min);
}

///////////////////////////////////////////////////////////////////////////////
function Vec2(x = 0.0, y = 0.0) {
	this.x = x;
	this.y = y;
}

Vec2.prototype.add = function(v) {
	this.x += v.x;
	this.y += v.y;
	return this;
};

Vec2.prototype.addScalar = function(s) {
	this.x += s;
	this.y += s;
	return this;
};

Vec2.prototype.addScaledVector = function(v, s) {
	this.x += v.x * s;
	this.y += v.y * s;
	return this;
};

Vec2.prototype.addVectors = function(a, b) {
	this.x = a.x + b.x;
	this.y = a.y + b.y;
	return this;
};

Vec2.prototype.copy = function(v) {
	this.x = v.x;
	this.y = v.y;
	return this;
};

Vec2.prototype.copyScaled = function(v, s) {
	this.x = v.x * s;
	this.y = v.y * s;
	return this;
};

Vec2.prototype.divide = function(v) {
	this.x /= v.x;
	this.y /= v.y;
	return this;
};

Vec2.prototype.divideScalar = function(s) {
	this.x /= s;
	this.y /= s;
	return this;
};

Vec2.prototype.dot = function(v) {
	return this.x * v.x + this.y * v.y;
};

Vec2.prototype.equals = function(v) {
	return this.x == v.x && this.y == v.y;
};

Vec2.prototype.length = function() {
	return Math.sqrt(this.x * this.x + this.y * this.y);
};

Vec2.prototype.lengthSq = function() {
	return (this.x * this.x + this.y * this.y);
};

Vec2.prototype.map = function(f) {
	this.x = f(this.x);
	this.y = f(this.y);
	return this;
};

Vec2.prototype.mapFrom = function(v, f) {
	this.x = f(v.x);
	this.y = f(v.y);
	return this;
};

Vec2.prototype.multiply = function(v) {
	this.x *= v.x;
	this.y *= v.y;
	return this;
};

Vec2.prototype.multiplyScalar = function(s) {
	this.x *= s;
	this.y *= s;
	return this;
};

Vec2.prototype.multiplyVectors = function(a, b) {
	this.x = a.x * b.x;
	this.y = a.y * b.y;
	return this;
};

Vec2.prototype.normalize = function() {
	return this.divideScalar(this.length());
};

Vec2.prototype.randomInUnitDisk = function() {
	do {
		this.x = 2.0 * Math.random() - 1.0;
		this.y = 2.0 * Math.random() - 1.0;
	} while(this.lengthSq() >= 1.0);
	return this;
};

Vec2.prototype.randomInRange = function(x1, x2, y1, y2) {
	this.x = Math.floor(Math.random() * (x2 - x1 + 1)) + x1;
	this.y = Math.floor(Math.random() * (y2 - y1 + 1)) + y1;
	return this;
};

Vec2.prototype.set = function(x, y) {
	this.x = x;
	this.y = y;
	return this;
};

Vec2.prototype.setScalar = function(s) {
	this.x = s;
	this.y = s;
	return this;
};

Vec2.prototype.sub = function(v) {
	this.x -= v.x;
	this.y -= v.y;
	return this;
};

Vec2.prototype.subScalar = function(s) {
	this.x -= s;
	this.y -= s;
	return this;
};

Vec2.prototype.subScaledVector = function(v, s) {
	this.x -= v.x * s;
	this.y -= v.y * s;
	return this;
};

Vec2.prototype.subVectors = function(a, b) {
	this.x = a.x - b.x;
	this.y = a.y - b.y;
	return this;
};

Vec2.prototype.clampLength = function(r) {
	const l = this.length();
	if(l > r) {
		this.multiplyScalar(r / l);
	}
	return this;
};

Vec2.prototype.toString = function Vec2ToString() {
	return "[" + this.x + ', ' + this.y + "]";
};

function getVec2DistanceSq(v1, v2) {
	const dx = v1.x - v2.x;
	const dy = v1.y - v2.y;
	return dx * dx + dy * dy;
}

function getVec2Distance(v1, v2) {
	const dx = v1.x - v2.x;
	const dy = v1.y - v2.y;
	return Math.sqrt(dx * dx + dy * dy);
}

function getVec2Angle(v1, v2) {
	return Math.atan2(v2.y - v1.y, v2.x - v1.x);
}

///////////////////////////////////////////////////////////////////////////////
function Particle(radius) {
	this.pos = new Vec2();
	this.vel = new Vec2();
	this.radius = radius;
	this.mass = 1;
	this.lineWidth = 0;
}

Particle.prototype.draw = function (context, color) {
	if (color === undefined) { color = "#ffffff"; }
	const x = Math.trunc(this.pos.x);
	const y = Math.trunc(this.pos.y);
	let r = Math.trunc(this.radius);

	context.save();
	context.fillStyle = color;
	if(r <= 1) {
		r = Math.abs(r);
		const d = r * 2;
		context.fillRect(x - r, y - r, d, d);
	}
	else {
		context.translate(Math.trunc(this.pos.x), Math.trunc(this.pos.y));
		context.lineWidth = 0;
		context.beginPath();
		context.arc(0, 0, Math.trunc(this.radius), 0, (Math.PI * 2), true);
		context.closePath();
		context.fill();
	}
	context.restore();
};

///////////////////////////////////////////////////////////////////////////////
function ParticleSwarm(width, height) {
	this.width = width;
	this.height = height;

	this.count = 10;
	this.radius = 3;
	this.radiusRandom = false;
	this.mass = 100;
	this.friction = 0.999;
	this.fall_acc = 0.0;
	this.clamp_speed = 7;
	this.repulsion_factor = 0.05;
	this.attraction_factor = 0.5;
	this.collisions = [];
	this.max_spawns = 50;
	this.spawn_prob = 0.1;

	this.reset();
}

ParticleSwarm.prototype.getMass = function(radius) {
	return Math.max(1, this.mass * Math.abs(radius));
}

ParticleSwarm.prototype.reset = function() {
	this.particles_list = [];
	for (i = 0; i < this.count; i++) {
		const radius = this.radiusRandom ? getRandomInt(0, this.radius) : this.radius;
		var particle = new Particle(radius);
		particle.pos.randomInRange(0, this.width, 0, this.height);
		particle.vel.randomInUnitDisk().multiplyScalar(3);
		particle.mass = this.getMass(radius);
		this.particles_list.push(particle);
	}
}

ParticleSwarm.prototype.getGravitationalForce = function(f, p1, p2, r, factor) {
	const angle = getVec2Angle(p1.pos, p2.pos);
	const force = factor * p1.mass * p2.mass * 1 / Math.pow(r, 2);
	f.set(force * Math.cos(angle), force * Math.sin(angle));
}

ParticleSwarm.prototype.getForce = function(p1, p2, r, store_collisions) {
	const f = new Vec2();
	const td = Math.abs(p1.radius) + Math.abs(p2.radius);
	if (r < td) {
		if(store_collisions && this.collisions.length < this.max_spawns) {
			this.collisions.push(new Vec2().copy(p1.pos).add(p2.pos).divideScalar(2));
		}

		if(this.repulsion_factor != 0 && r != 0) {
			this.getGravitationalForce(f, p1, p2, r, -this.repulsion_factor);
		}
	}
	else {
		if(this.attraction_factor != 0) {
			this.getGravitationalForce(f, p1, p2, r, this.attraction_factor);
		}
	}
	f.y += this.fall_acc;
	return f;
};

ParticleSwarm.prototype.torusProjection = function(pos) {
	pos.x = pos.x % this.width;
	if(pos.x < 0)
		pos.x += this.width;
	pos.y = pos.y % this.height;
	if(pos.y < 0)
		pos.y += this.height;
}

ParticleSwarm.prototype.move = function(particle) {
	particle.vel.multiplyScalar(this.friction);
	particle.pos.add(particle.vel);
	this.torusProjection(particle.pos);
};

ParticleSwarm.prototype.attractTo = function(p1, p2, store_collisions=false) {
	const m1 = p1.mass;
	const r = getVec2Distance(p1.pos, p2.pos);
	const force = this.getForce(p1, p2, r, store_collisions);
	force.divideScalar(m1);
	p1.vel.add(force); // a = F/m
	p1.vel.clampLength(this.clamp_speed);
};

ParticleSwarm.prototype.attractParticles = function(p1, p2) {
	this.attractTo(p1, p2, true);
	this.attractTo(p2, p1);
};

ParticleSwarm.prototype.computeForcesAndCollisions = function() {
	this.collisions = [];
	for (i = 0; i < this.particles_list.length; i++) {
		for (j = i + 1; j < this.particles_list.length; j++) {
			this.attractParticles(this.particles_list[i], this.particles_list[j]);
		}
	}
}

ParticleSwarm.prototype.spawnParticles = function() {
	for(let i = 0; i < this.collisions.length; ++i) {
		if(Math.random() >= this.spawn_prob)
			continue;
		let particle = null;
		const radius = this.radiusRandom ? getRandomInt(0, this.radius) : this.radius;
		if(this.particles_list.length >= this.count + this.max_spawns) {
			particle = this.particles_list[getRandomInt(this.count, this.particles_list.length - 1)];
			particle.radius = radius;
		}
		else {
			particle = new Particle(radius);
			this.particles_list.push(particle);
		}
		particle.pos.copy(this.collisions[i]);
		particle.vel.randomInUnitDisk().multiplyScalar(3);
		particle.mass = this.getMass(radius);
	}
}

ParticleSwarm.prototype.moveAndDraw = function(context) {
	for (i = 0; i < this.particles_list.length; i++) {
		const particle = this.particles_list[i];
		this.move(particle);

		const color = CSS_COLOR_NAMES[i % CSS_COLOR_NAMES.length];
		particle.draw(context, color);
	}
}

ParticleSwarm.prototype.draw = function(context) {
	this.computeForcesAndCollisions();
	this.spawnParticles();
	this.moveAndDraw(context);
};

///////////////////////////////////////////////////////////////////////////////
const particles = new ParticleSwarm(canvasW, canvasH);

let fade_factor = 0;
let blur_enabled = false;
let bg_r = 0;
let bg_g = 0;
let bg_b = 0;
let rotatePerFrame = 0;
let translateX = 0;
let translateY = 0;

function readParameters() {
	fade_factor = parseFloat(document.getElementById("ID_FADE").value);
	blur_enabled = document.getElementById("ID_BLUR").checked;
	bg_r = parseFloat(document.getElementById("ID_BG_R").value);
	bg_g = parseFloat(document.getElementById("ID_BG_G").value);
	bg_b = parseFloat(document.getElementById("ID_BG_B").value);
	rotatePerFrame = parseFloat(document.getElementById("ID_ROTATE").value);
	translateX = parseFloat(document.getElementById("ID_TRANSLATE_X").value);
	translateY = parseFloat(document.getElementById("ID_TRANSLATE_Y").value);

	particles.count = parseFloat(document.getElementById("ID_PARTICLES").value);
	particles.radius = parseFloat(document.getElementById("ID_RADIUS").value);
	particles.radiusRandom = document.getElementById("ID_RADIUS_RANDOM").checked;
	particles.mass = parseFloat(document.getElementById("ID_MASS").value);
	particles.repulsion_factor = parseFloat(document.getElementById("ID_REPULSION").value);
	particles.attraction_factor = parseFloat(document.getElementById("ID_ATTRACTION").value);
	particles.friction = parseFloat(document.getElementById("ID_FRICTION").value);
	particles.clamp_speed = parseFloat(document.getElementById("ID_CLAMP_SPEED").value);
	particles.max_spawns = parseFloat(document.getElementById("ID_SPAWN").value);
	particles.spawn_prob = parseFloat(document.getElementById("ID_SPAWN_PROB").value);
}
readParameters();
particles.reset();

function fadeImage(context, r, g, b, a) {
	context.save();
	context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
	context.fillRect(0, 0, canvasW, canvasH);
	context.restore();
}

// https://www.htmlgoodies.com/html5/other/create-negative-blur-and-rotate-image-effects-using-the-html5-canvas.html
function blurImage(context, passes=1) {
	const imgData = context.getImageData(0, 0, canvasW, canvasH);
	var i, x, y;
	context.globalAlpha = 0.125;
	for (i = 1; i <= passes; i++) {
		for (y = -1; y < 2; y++) {
			for (x = -1; x < 2; x++) {
				context.drawImage(imgData, x, y);
			}
		}
	}
	context.globalAlpha = 1.0;
}

function rotateImage(context, angle) {
	const imgData = context.getImageData(0, 0, canvasW, canvasH);
	context.save();
	context.translate(canvasW/2, canvasH/2);
	context.rotate(angle * Math.PI / 180);
	context.translate(-(canvasW/2), -(canvasH/2));
	context.drawImage(imgData, 0, 0, canvasW, canvasH);
	context.restore();
}

function translateImage(context, dx, dy) {
	const imgData = context.getImageData(0, 0, canvasW, canvasH);
	context.putImageData(imgData, dx, dy);
}

window.onload = function() {
	const context = canvas.getContext('2d');
	context.fillStyle = "black";
	context.fillRect(0, 0, canvasW, canvasH);

	(function drawFrame () {
		window.requestAnimationFrame(drawFrame, canvas);

		fadeImage(context, bg_r, bg_g, bg_b, fade_factor);

		particles.draw(context);

		if(!(translateX == 0 && translateY == 0)) {
			translateImage(context, translateX, translateY);
		}

		if(rotatePerFrame != 0) {
			rotateImage(context, rotatePerFrame);
		}

		if(blur_enabled) {
			blurImage(context);
		}
	}());
}

let lockReset = false;
function onResetButton() {
	if(lockReset) {
		return;
	}

	const context = canvas.getContext('2d');
	context.save();
	context.fillStyle = 'rgb(' + bg_r + ',' + bg_g + ',' + bg_b + ')';
	context.clearRect(0, 0, canvasW, canvasH);
	context.fillRect(0, 0, canvasW, canvasH);
	context.restore();

	readParameters();
	particles.reset();
}

function onRandomizeButton() {
	lockReset = true;
	{
		document.getElementById("ID_PARTICLES").value = getRandomInt(1, 200);
		document.getElementById("ID_RADIUS").value = getRandomInt(-50, 50);
		document.getElementById("ID_RADIUS_RANDOM").checked = (Math.random() < 0.5);
		document.getElementById("ID_MASS").value = getRandom(1, 200);
		document.getElementById("ID_REPULSION").value = getRandom(-50, 50);
		document.getElementById("ID_ATTRACTION").value = getRandom(-50, 50);
		document.getElementById("ID_FRICTION").value = getRandom(0, 1);
		document.getElementById("ID_CLAMP_SPEED").value = getRandom(0.01, 50);
		document.getElementById("ID_SPAWN").value = getRandomInt(0, 100);
		document.getElementById("ID_SPAWN_PROB").value = (Math.random() < 0.5) ? 0 : getRandom(0, 1);

		document.getElementById("ID_BG_R").value = getRandomInt(0, 255);
		document.getElementById("ID_BG_G").value = getRandomInt(0, 255);
		document.getElementById("ID_BG_B").value = getRandomInt(0, 255);

		document.getElementById("ID_FADE").value = getRandom(0, 0.5);
		document.getElementById("ID_ROTATE").value = (Math.random() < 0.5) ? 0 : getRandom(-10, 10);
		document.getElementById("ID_TRANSLATE_X").value = getRandom(-10, 10);
		document.getElementById("ID_TRANSLATE_Y").value = getRandom(-10, 10);
	}
	lockReset = false;
	onResetButton();
}

function onSaveButton() {
	var image = canvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
	window.location.href = image;
}

</script>

</body>
</html>
